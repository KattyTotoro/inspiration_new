<template>
  <div>
    <p>
    Уровень 1: Базовое понимание (Синтаксис, Привязка данных, События) <br>
Задача 1: "Счетчик с ограничением" <br>

Цель: Проверить знание реактивных данных (ref), обработки событий (@click) и условной отрисовки (v-if/v-disabled).
<br>
Условие:
Создайте компонент счетчика, который:
<br>
Начинается с 0.

Имеет кнопку "+", которая увеличивает счетчик на 1.

Имеет кнопку "-", которая уменьшает счетчик на 1.

Кнопка "-" должна быть заблокирована (атрибут disabled), когда счетчик равен 0.

Текущее значение счетчика отображается на странице.<br>

Вопрос на понимание:

Почему мы используем ref для переменной count, а не просто обычную переменную?

Как бы вы реализовали блокировку кнопки? Через v-if или v-disabled? В чем разница в данном контексте?
    </p>
  </div>
  <div>
<button class="training" @click="number--" :disabled="number==0"> - </button>

{{number}}

<button class="training" @click="number++"> + </button>
  </div>

<br>
<br>
<br>
  <div>
  <p>
  Задача 2: "Список дел (To-Do List)"<br>

Цель: Работа со списками (v-for), обработка ввода из формы и модификация массива.<br>

Условие:
Создайте простой список дел:<br>

Поле ввода (input) и кнопка "Добавить".

При нажатии на кнопку (или на Enter) текст из поля ввода добавляется в список.

Каждый элемент списка отображается как < li > и имеет кнопку "Удалить", которая удаляет этот элемент из списка.

Если список пуст, отображается параграф "Список дел пуст".<br>

Вопрос на понимание:

Почему важно назначать уникальный :key для каждого элемента в v-for?

Почему мы не можем напрямую изменять параметр элемента в цикле v-for (например, item.text = 'новый текст')? Что нужно сделать вместо этого?
  </p>  
  </div>

  <div>
<form @submit.prevent="addtodo">
  <input class="training" type="text" v-model="text">
  <button class="training">Добавить</button>
</form>
  <p v-if="!todo.length">Список пуст</p>
  <ul v-else>
    <li v-for="el, i of todo" :key="el+i">
      {{ el }} 
      <input class="training" type="text" v-model="el.text"></input>
      <button class="training" @click="todo.splice(i, 1)">Удалить</button>
    </li>
  </ul>
  {{ todo }}
  </div>

  <div>
  <p>
  Уровень 2: Реактивность и Жизненный цикл
Задача 3: "Поиск с debounce"

Цель: Понимание watch и computed, а также концепции "отложенного" выполнения.

Условие:
У вас есть поле поиска и список элементов (например, городов).

При вводе текста в поле поиска, список должен фильтроваться.

Фильтрация не должна происходить на каждое нажатие клавиши. Нужно реализовать задержку (debounce) в 500 мс. То есть запрос на фильтрацию должен срабатывать только тогда, когда пользователь перестал печатать на 500 мс.

Подсказка: Используйте watch для отслеживания поля ввода и setTimeout/clearTimeout.

Вопрос на понимание:

В чем разница между watch и computed? В какой ситуации вы бы использовали computed для этой задачи, а в какой watch?

Почему важно очищать таймаут (clearTimeout) в функции-наблюдателе?
</p>
  </div>

</template>

<script setup lang="ts">

const number = ref(0)
const todo = ref([] as any[])
const text = ref('')

const addtodo = ()=>{
  todo.value.push({text:text.value})
  text.value=''
}


</script>

<style>
.training {
  background-color: rgb(106, 106, 233);
  padding: 20px 50px;
  border: 1px solid grey;
  border-radius: 10px;
  font-size: 28px;
  font-weight: 600;
  margin: 20px;
}


</style>